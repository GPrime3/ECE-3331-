#include <msp430.h>

// Much simpler timing - no PWM, just on/off with delays
#define BIT_DURATION    10000  // 10ms per bit - slow enough for receiver
#define CARRIER_CYCLES  38     // 38 cycles of 38kHz per carrier burst
#define CARRIER_PERIOD  10     // 26 cycles ≈ 38kHz (8MHz/38kHz ≈ 210)

unsigned char signal[4];
unsigned int repeat_counter = 0;
unsigned int send_count = 0;        // NEW: Track number of sends
#define REPEAT_DELAY    50
#define MAX_SENDS       3           // NEW: Maximum signals per button hold

// Simple function to generate 38kHz carrier bursts
void carrier_burst(unsigned int duration) {
    unsigned int i, j;
    
    for(i = 0; i < duration; i++) {
        // Generate 38kHz for one cycle
        P2OUT |= BIT7;   // IR LED ON
        __delay_cycles(CARRIER_PERIOD/2);
        P2OUT &= ~BIT7;  // IR LED OFF  
        __delay_cycles(CARRIER_PERIOD/2);
    }
}

void send_signal(void) {
    unsigned long i;
    
    // Send all 4 bits with clear separation
    for(i = 0; i < 4; i++) {
        if(signal[i] == 1) {
            // Bit '1': Long carrier burst
            carrier_burst(CARRIER_CYCLES * 3);  // 3x longer than bit 0
        } else {
            // Bit '0': Short carrier burst
            carrier_burst(CARRIER_CYCLES);
        }
        
        // Fixed gap between bits (no carrier)
        __delay_cycles(BIT_DURATION);
    }
}

int main(void) {
    unsigned long i;
    unsigned char button_state = 0;
    unsigned char last_button_state = 0;

    WDTCTL = WDTPW | WDTHOLD;
    PM5CTL0 &= ~LOCKLPM5;

    // LEDs
    P2DIR |= BIT1 | BIT2;
    P1DIR |= BIT3 | BIT5;
    P3DIR |= BIT6;
    P2OUT |= (BIT1 | BIT2);
    P1OUT |= BIT3;
    P1OUT &= ~BIT5;
    P3OUT |= BIT6;

    // Buttons
    P3DIR &= ~(BIT0 | BIT1 | BIT3);
    P3REN |= (BIT0 | BIT1 | BIT3);
    P3OUT &= ~(BIT0 | BIT1 | BIT3);
    P2DIR &= ~(BIT6|BIT3|BIT2);
    P2REN |= BIT6|BIT3|BIT2;
    P2OUT &= ~(BIT6|BIT3|BIT2);
    P1DIR &= ~(BIT3);
    P1REN |= (BIT3);
    P1OUT &= ~(BIT3);

    // P2.7 as simple GPIO for IR LED (no PWM)
    P2DIR |= BIT7;
    P2SEL0 &= ~BIT7;
    P2SEL1 &= ~BIT7;
    P2OUT &= ~BIT7;

    // Startup blink
    for(i = 0; i < 5; i++) {
        P1OUT ^= BIT5;
        __delay_cycles(800000);
    }
    P1OUT &= ~BIT5;
    __delay_cycles(1000000);

    while(1) {
        __delay_cycles(2000);
        
        // Read button states
        button_state = 0;
        
        if((P3IN & BIT0) != 0) {
            button_state = 1;
        } else if((P3IN & BIT1) != 0) {
            button_state = 2;
        } else if((P2IN & BIT6) != 0) {
            button_state = 3;
        } else if((P3IN & BIT3) != 0) {
            button_state = 4;
        } else if((P2IN & BIT3) != 0) {
            button_state = 5;
        } else if((P2IN & BIT2) != 0) {
            button_state = 6;
        } else if((P1IN & BIT3) != 0) {
            button_state = 7;
        }
        
        // Handle button press and repeat
        if(button_state != 0) {
            // NEW BUTTON PRESS
            if(button_state != last_button_state) {
                repeat_counter = 0;
                send_count = 0;         // Reset send counter on new button
                
                switch(button_state) {
                    case 1:  // 0001
                        P1OUT &= ~BIT3;
                        signal[0] = 0; signal[1] = 0; signal[2] = 0; signal[3] = 1;
                        break;
                    case 2:  // 0010
                        P3OUT &= ~BIT6;
                        signal[0] = 0; signal[1] = 0; signal[2] = 1; signal[3] = 0;
                        break;
                    case 3:  // 0100
                        P2OUT &= ~BIT1;
                        signal[0] = 0; signal[1] = 1; signal[2] = 0; signal[3] = 0;
                        break;
                    case 4:  // 1000
                        P2OUT &= ~BIT2;
                        signal[0] = 1; signal[1] = 0; signal[2] = 0; signal[3] = 0;
                        break;
                    case 5:  // 1100
                        P2OUT &= ~BIT2;
                        signal[0] = 1; signal[1] = 1; signal[2] = 0; signal[3] = 0;
                        break;
                    case 6:  // 1110
                        P2OUT &= ~BIT2;
                        signal[0] = 1; signal[1] = 1; signal[2] = 1; signal[3] = 0;
                        break;
                    case 7:  // 1001
                        P2OUT &= ~BIT2;
                        signal[0] = 1; signal[1] = 0; signal[2] = 0; signal[3] = 1;
                        break;
                }
                
                // Send first signal immediately
                send_signal();
                send_count++;           // Increment send counter
            } 
            // BUTTON HELD - SEND REPEATS (but max 3 total)
            else if(repeat_counter >= REPEAT_DELAY && send_count < MAX_SENDS) {
                send_signal();
                send_count++;           // Increment send counter
                repeat_counter = 0;
            }
            
            repeat_counter++;
        } else {
            // Button released - reset counters
            repeat_counter = 0;
            send_count = 0;
        }
        
        // Reset LEDs when button released
        if(button_state == 0 && last_button_state != 0) {
            P1OUT |= BIT3;
            P3OUT |= BIT6;
            P2OUT |= BIT1;
            P2OUT |= BIT2;
        }
        
        last_button_state = button_state;
        
        __delay_cycles(1000);
    }
}
