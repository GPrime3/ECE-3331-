#include <msp430.h>

#define CMD_LENGTH 4

int main(void)
{
    unsigned int i;
    unsigned char received_cmd = 0;
    unsigned int burst_length;
    unsigned int timeout;
    unsigned char valid_decode = 0;
    unsigned int min_burst = 9999;
    unsigned int max_burst = 0;
    unsigned int threshold;

    WDTCTL = WDTPW | WDTHOLD;
    PM5CTL0 &= ~LOCKLPM5;

    // LED setup
    P3DIR |= BIT0 | BIT3 | BIT6 | BIT7;
    P2DIR |= BIT2;
    P3OUT &= ~(BIT0 | BIT3 | BIT6 | BIT7);
    P2OUT &= ~BIT2;

    // TSOP receiver setup (P3.1)
    P3DIR &= ~BIT1;
    P3REN &= ~BIT1;
    P3SEL0 &= ~BIT1;
    P3SEL1 &= ~BIT1;

    // Startup blink
    for(i = 0; i < 10; i++) {
        P3OUT |= (BIT0 | BIT3 | BIT6 | BIT7);
        P2OUT |= BIT2;
        __delay_cycles(200000);
        P3OUT &= ~(BIT0 | BIT3 | BIT6 | BIT7);
        P2OUT &= ~BIT2;
        __delay_cycles(200000);
    }

    while (1)
    {
        // Real-time IR detection
        if((P3IN & BIT1) == 0) {
            P3OUT |= BIT0;
        } else {
            P3OUT &= ~BIT0;
        }
        
        // Wait for IR signal start
        if((P3IN & BIT1) != 0) {
            P3OUT &= ~(BIT3 | BIT6 | BIT7);
            P2OUT &= ~BIT2;
            __delay_cycles(1000);
            continue;
        }
        
        // IR signal detected - wait to skip initial partial transmissions
        __delay_cycles(200000);  // Wait ~25ms
        
        // Check if signal is still present
        if((P3IN & BIT1) != 0) {
            continue;
        }
        
        // Wait for current burst to end
        timeout = 0;
        while((P3IN & BIT1) == 0) {
            timeout++;
            if(timeout > 10000) break;
            __delay_cycles(10);
        }
        
        // Wait for next transmission to begin
        timeout = 0;
        while((P3IN & BIT1) != 0) {
            timeout++;
            if(timeout > 10000) {
                continue;
            }
            __delay_cycles(10);
        }
        
        // Fresh transmission detected - decode 4 bits
        received_cmd = 0;
        valid_decode = 1;
        min_burst = 9999;
        max_burst = 0;
        
        unsigned int burst_lengths[4];
        
        for(i = 0; i < CMD_LENGTH; i++)
        {
            if(i > 0) {
                timeout = 0;
                while((P3IN & BIT1) != 0) {
                    timeout++;
                    if(timeout > 5000) {
                        valid_decode = 0;
                        break;
                    }
                    __delay_cycles(10);
                }
                if(!valid_decode) break;
            }
            
            // Measure burst length
            burst_length = 0;
            while((P3IN & BIT1) == 0) {
                burst_length++;
                if(burst_length > 3000) {
                    valid_decode = 0;
                    break;
                }
                __delay_cycles(1);
            }
            if(!valid_decode) break;
            
            // Reject bursts that are too short (noise)
            if(burst_length < 15) {
                valid_decode = 0;
                break;
            }
            
            burst_lengths[i] = burst_length;
            
            // Track min and max
            if(burst_length < min_burst) {
                min_burst = burst_length;
            }
            if(burst_length > max_burst) {
                max_burst = burst_length;
            }
            
            __delay_cycles(3000);
        }
        
        if(!valid_decode) {
            continue;
        }
        
        // Validate that we have both short and long bursts
        // (otherwise all bits are the same, which is invalid for our commands)
        if(max_burst < (min_burst * 1.5)) {
            // Bursts are too similar - not a valid signal
            continue;
        }
        
        // Calculate threshold
        threshold = (min_burst + max_burst) / 2;
        
        // Decode the bits
        received_cmd = 0;
        for(i = 0; i < CMD_LENGTH; i++) {
            received_cmd <<= 1;
            if(burst_lengths[i] > threshold) {
                received_cmd |= 1;
            }
        }
        
        // Validate command - only accept known valid commands
        if(received_cmd != 0x01 && received_cmd != 0x02 && 
           received_cmd != 0x04 && received_cmd != 0x08) {
            // Invalid command - ignore it
            continue;
        }
        
        // Turn off all command LEDs
        P3OUT &= ~(BIT3 | BIT6 | BIT7);
        P2OUT &= ~BIT2;
        
        // Light up correct LED
        switch(received_cmd)
        {
            case 0x01:  // Button 1
                P3OUT |= BIT3;
                __delay_cycles(1000000);
                P3OUT &= ~BIT3;
                break;
                
            case 0x02:  // Button 2
                P3OUT |= BIT6;
                __delay_cycles(1000000);
                P3OUT &= ~BIT6;
                break;
                
            case 0x04:  // Button 3
                P3OUT |= BIT7;
                __delay_cycles(1000000);
                P3OUT &= ~BIT7;
                break;
                
            case 0x08:  // Button 4
                P2OUT |= BIT2;
                __delay_cycles(1000000);
                P2OUT &= ~BIT2;
                break;
        }
        
        // Longer delay before next decode
        __delay_cycles(100000);
    }
}
