#include <msp430.h>

// PWM configuration for 38kHz
#define F_SMCLK        8000000UL
#define F_PWM          38000UL
#define CCR0VAL        ((F_SMCLK/F_PWM)-1)

unsigned char signal[4];

int main(void) {
    unsigned long i;
    unsigned char button1_prev = 0, button2_prev = 0, button3_prev = 0, button4_prev = 0;
    unsigned char button1_curr, button2_curr, button3_curr, button4_curr;

    WDTCTL = WDTPW | WDTHOLD;
    PM5CTL0 &= ~LOCKLPM5;

    // LEDs
    P2DIR |= BIT1 | BIT2;
    P1DIR |= BIT3 | BIT5;
    P3DIR |= BIT6;
    P2OUT |= (BIT1 | BIT2);
    P1OUT |= BIT3;
    P1OUT &= ~BIT5;
    P3OUT |= BIT6;

    // Buttons with pull-up resistors
    P3DIR &= ~(BIT0 | BIT1 | BIT3);
    P3REN |= (BIT0 | BIT1 | BIT3);
    P3OUT |= (BIT0 | BIT1 | BIT3);
    P2DIR &= ~BIT6;
    P2REN |= BIT6;
    P2OUT |= BIT6;

    // P2.7 PWM for IR LED (TB0.6)
    P2DIR |= BIT7;
    P2SEL0 |= BIT7;
    P2SEL1 &= ~BIT7;

    // Timer setup for 38kHz carrier with variable duty cycle
    TB0CCR0 = CCR0VAL;
    TB0CCR6 = (CCR0VAL + 1) * 0.33;
    TB0CCTL6 = OUTMOD_0;  // PWM disabled initially
    TB0CTL = TBSSEL_2 | MC_1 | TBCLR;
    
    P2OUT &= ~BIT7;

    // Startup blink
    for(i = 0; i < 5; i++) {
        P1OUT ^= BIT5;
        __delay_cycles(800000);
    }
    P1OUT &= ~BIT5;
    __delay_cycles(4000000);

    while(1) {
        // Read current button states (active LOW)
        button1_curr = (P3IN & BIT0) ? 0 : 1;
        button2_curr = (P3IN & BIT1) ? 0 : 1;
        button3_curr = (P2IN & BIT6) ? 0 : 1;
        button4_curr = (P3IN & BIT3) ? 0 : 1;

        // Button 1: Detect rising edge (button press, not hold)
        if(button1_curr && !button1_prev) {
            while(button1_curr && !button1_prev){
            P1OUT &= ~BIT3;  // LED ON
            
            // Button 1: 0001
            signal[0] = 0;
            signal[1] = 0;
            signal[2] = 0;
            signal[3] = 1;
            
            for(i = 0; i < 4; i++) {
                if(signal[i] == 1) {
                    // Bit '1': 75% duty cycle, 32 carrier cycles
                    TB0CCR6 = (CCR0VAL + 1) * 0.75;
                    TB0CCTL6 = OUTMOD_7;
                    __delay_cycles(CCR0VAL * 32);
                    TB0CCTL6 = OUTMOD_0;
                    P2OUT &= ~BIT7;
                } else {
                    // Bit '0': 25% duty cycle, 16 carrier cycles
                    TB0CCR6 = (CCR0VAL + 1) * 0.25;
                    TB0CCTL6 = OUTMOD_7;
                    __delay_cycles(CCR0VAL * 16);
                    TB0CCTL6 = OUTMOD_0;
                    P2OUT &= ~BIT7;
                }
                __delay_cycles(CCR0VAL * 8);  // Gap between bits
            }
            
            // Debounce delay
            __delay_cycles(200000);
            }
        }
        
        // Update LED state (off when button released)
        if(!button1_curr) {
            P1OUT |= BIT3;  // LED OFF
        }

        // Button 2: Detect rising edge
        if(button2_curr && !button2_prev) {
            while(button2_curr && !button2_prev){
            P3OUT &= ~BIT6;
        
            
            // Button 2: 0010
            signal[0] = 0;
            signal[1] = 0;
            signal[2] = 1;
            signal[3] = 0;
            
            for(i = 0; i < 4; i++) {
                if(signal[i] == 1) {
                    TB0CCR6 = (CCR0VAL + 1) * 0.75;
                    TB0CCTL6 = OUTMOD_7;
                    __delay_cycles(CCR0VAL * 32);
                    TB0CCTL6 = OUTMOD_0;
                    P2OUT &= ~BIT7;
                } else {
                    TB0CCR6 = (CCR0VAL + 1) * 0.25;
                    TB0CCTL6 = OUTMOD_7;
                    __delay_cycles(CCR0VAL * 16);
                    TB0CCTL6 = OUTMOD_0;
                    P2OUT &= ~BIT7;
                }
                __delay_cycles(CCR0VAL * 8);
            }
            __delay_cycles(200000);
        }
        }
        
        if(!button2_curr) {
            P3OUT |= BIT6;
        }

        // Button 3: Detect rising edge
        if(button3_curr && !button3_prev) {
            while(button3_curr && !button3_prev){
            P2OUT &= ~BIT1;
            
            // Button 3: 0100
            signal[0] = 0;
            signal[1] = 1;
            signal[2] = 0;
            signal[3] = 0;
            
            for(i = 0; i < 4; i++) {
                if(signal[i] == 1) {
                    TB0CCR6 = (CCR0VAL + 1) * 0.75;
                    TB0CCTL6 = OUTMOD_7;
                    __delay_cycles(CCR0VAL * 32);
                    TB0CCTL6 = OUTMOD_0;
                    P2OUT &= ~BIT7;
                } else {
                    TB0CCR6 = (CCR0VAL + 1) * 0.25;
                    TB0CCTL6 = OUTMOD_7;
                    __delay_cycles(CCR0VAL * 16);
                    TB0CCTL6 = OUTMOD_0;
                    P2OUT &= ~BIT7;
                }
                __delay_cycles(CCR0VAL * 8);
            }
            __delay_cycles(200000);
        }
        }
        if(!button3_curr) {
            P2OUT |= BIT1;
        }

        // Button 4: Detect rising edge
        if(button4_curr && !button4_prev) {
            while(button4_curr && !button4_prev){
            P2OUT &= ~BIT2;
            
            // Button 4: 1000
            signal[0] = 1;
            signal[1] = 0;
            signal[2] = 0;
            signal[3] = 0;
            
            for(i = 0; i < 4; i++) {
                if(signal[i] == 1) {
                    TB0CCR6 = (CCR0VAL + 1) * 0.75;
                    TB0CCTL6 = OUTMOD_7;
                    __delay_cycles(CCR0VAL * 32);
                    TB0CCTL6 = OUTMOD_0;
                    P2OUT &= ~BIT7;
                } else {
                    TB0CCR6 = (CCR0VAL + 1) * 0.25;
                    TB0CCTL6 = OUTMOD_7;
                    __delay_cycles(CCR0VAL * 16);
                    TB0CCTL6 = OUTMOD_0;
                    P2OUT &= ~BIT7;
                }
                __delay_cycles(CCR0VAL * 8);
            }
            __delay_cycles(200000);
        }
        }
        
        if(!button4_curr) {
            P2OUT |= BIT2;
        }

        // Store current button states for next iteration
        button1_prev = button1_curr;
        button2_prev = button2_curr;
        button3_prev = button3_curr;
        button4_prev = button4_curr;

        // Ensure PWM is off when idle
        TB0CCTL6 = OUTMOD_0;
        P2OUT &= ~BIT7;
        
        // Small delay for polling
        __delay_cycles(5000);
    }
}
