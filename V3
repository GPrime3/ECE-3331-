#include <msp430.h>

// PWM configuration for 38kHz
#define F_SMCLK        8000000UL
#define F_PWM          38000UL
#define CCR0VAL        ((F_SMCLK/F_PWM)-1)
#define REPEAT_GAP     (CCR0VAL * 100)  // Gap between repeat transmissions

unsigned char signal[4];

void send_signal(void) {
    unsigned long i;
    
    for(i = 0; i < 4; i++) {
        if(signal[i] == 1) {
            // Bit '1': 75% duty cycle, 32 carrier cycles
            TB0CCR6 = (CCR0VAL + 1) * 0.33;
            TB0CCTL6 = OUTMOD_7;
            __delay_cycles(CCR0VAL * 32);
            TB0CCTL6 = OUTMOD_0;
            P2OUT &= ~BIT7;
        } else {
            // Bit '0': 25% duty cycle, 16 carrier cycles
            TB0CCR6 = (CCR0VAL + 1) * 0.33;
            TB0CCTL6 = OUTMOD_7;
            __delay_cycles(CCR0VAL * 16);
            TB0CCTL6 = OUTMOD_0;
            P2OUT &= ~BIT7;
        }
        __delay_cycles(CCR0VAL * 8);  // Gap between bits
    }
}

int main(void) {
    unsigned long i;
    unsigned char button_state = 0;

    WDTCTL = WDTPW | WDTHOLD;
    PM5CTL0 &= ~LOCKLPM5;

    // LEDs
    P2DIR |= BIT1 | BIT2;
    P1DIR |= BIT3 | BIT5;
    P3DIR |= BIT6;
    P2OUT |= (BIT1 | BIT2);
    P1OUT |= BIT3;
    P1OUT &= ~BIT5;
    P3OUT |= BIT6;

    // Buttons with pull-down resistors
    P3DIR &= ~(BIT0 | BIT1 | BIT3);  // INPUT
    P3REN |= (BIT0 | BIT1 | BIT3);   // Enable resistor
    P3OUT &= ~(BIT0 | BIT1 | BIT3);  // Pull-DOWN (LOW)
    P2DIR &= ~BIT6;
    P2REN |= BIT6;
    P2OUT &= ~BIT6;  // Pull-DOWN for consistency

    // P2.7 PWM for IR LED (TB0.6)
    P2DIR |= BIT7;
    P2SEL0 |= BIT7;
    P2SEL1 &= ~BIT7;

    // Timer setup for 38kHz carrier with variable duty cycle
    TB0CCR0 = CCR0VAL;
    TB0CCR6 = (CCR0VAL + 1) * 0.33;
    TB0CCTL6 = OUTMOD_0;  // PWM disabled initially
    TB0CTL = TBSSEL_2 | MC_1 | TBCLR;
    
    P2OUT &= ~BIT7;

    // Startup blink
    for(i = 0; i < 5; i++) {
        P1OUT ^= BIT5;
        __delay_cycles(800000);
    }
    P1OUT &= ~BIT5;
    __delay_cycles(1000000);

    while(1) {
        // Debounce delay before reading buttons
        __delay_cycles(10000);
        
        // Read button states and determine which one is pressed
        // Priority: Button 1 > Button 2 > Button 3 > Button 4
        button_state = 0;  // Default: no button pressed
        
        if((P3IN & BIT0) != 0) {  // Active HIGH with pull-down
            button_state = 1;
        } else if((P3IN & BIT1) != 0) {
            button_state = 2;
        } else if((P2IN & BIT6) != 0) {
            button_state = 3;
        } else if((P3IN & BIT3) != 0) {
            button_state = 4;
        }
        
        // Process button based on state
        switch(button_state) {
            case 1:  // Button 1 pressed
                P1OUT &= ~BIT3;  // LED ON
                
                // Button 1: 0001
                signal[0] = 0;
                signal[1] = 0;
                signal[2] = 0;
                signal[3] = 1;
                
                send_signal();
                __delay_cycles(REPEAT_GAP);
                break;
                
            case 2:  // Button 2 pressed
                P3OUT &= ~BIT6;
                
                // Button 2: 0010
                signal[0] = 0;
                signal[1] = 0;
                signal[2] = 1;
                signal[3] = 0;
                
                send_signal();
                __delay_cycles(REPEAT_GAP);
                break;
                
            case 3:  // Button 3 pressed
                P2OUT &= ~BIT1;
                
                // Button 3: 0100
                signal[0] = 0;
                signal[1] = 1;
                signal[2] = 0;
                signal[3] = 0;
                
                send_signal();
                __delay_cycles(REPEAT_GAP);
                break;
                
            case 4:  // Button 4 pressed
                P2OUT &= ~BIT2;
                
                // Button 4: 1000
                signal[0] = 1;
                signal[1] = 0;
                signal[2] = 0;
                signal[3] = 0;
                
                send_signal();
                __delay_cycles(REPEAT_GAP);
                break;
                
            default:  // No button pressed
                // Turn off all LEDs
                P1OUT |= BIT3;
                P3OUT |= BIT6;
                P2OUT |= BIT1;
                P2OUT |= BIT2;
                
                // Ensure PWM is off
                TB0CCTL6 = OUTMOD_0;
                P2OUT &= ~BIT7;
                break;
        }
        
        // Small delay for polling
        __delay_cycles(5000);
    }
}
