#include <msp430.h>

#define CMD_LENGTH 4

int main(void)
{
    unsigned int i;
    unsigned char received_cmd = 0;
    unsigned int burst_length;
    unsigned int timeout;
    unsigned char valid_decode = 0;
    unsigned int min_burst = 9999;
    unsigned int max_burst = 0;
    unsigned int threshold;

    WDTCTL = WDTPW | WDTHOLD;
    PM5CTL0 &= ~LOCKLPM5;

    // LED setup
    P3DIR |= BIT0 | BIT3 | BIT6 | BIT7;  // P3.0 (IR detect), P3.3, P3.6, P3.7
    P2DIR |= BIT2;                        // P2.2
    P3OUT &= ~(BIT0 | BIT3 | BIT6 | BIT7);
    P2OUT &= ~BIT2;

    // TSOP receiver setup (P3.1)
    P3DIR &= ~BIT1;
    P3REN &= ~BIT1;
    P3SEL0 &= ~BIT1;
    P3SEL1 &= ~BIT1;

    // Startup blink - all LEDs
    for(i = 0; i < 10; i++) {
        P3OUT |= (BIT0 | BIT3 | BIT6 | BIT7);
        P2OUT |= BIT2;
        __delay_cycles(200000);
        P3OUT &= ~(BIT0 | BIT3 | BIT6 | BIT7);
        P2OUT &= ~BIT2;
        __delay_cycles(200000);
    }

    while (1)
    {
        // Real-time IR detection on P3.0
        if((P3IN & BIT1) == 0) {
            P3OUT |= BIT0;  // IR detected
        } else {
            P3OUT &= ~BIT0;  // No IR
        }
        
        // Wait for IR signal start
        if((P3IN & BIT1) != 0) {
            // No signal - turn off command LEDs
            P3OUT &= ~(BIT3 | BIT6 | BIT7);
            P2OUT &= ~BIT2;
            __delay_cycles(1000);
            continue;
        }
        
        // Signal detected - start decoding 4 bits
        received_cmd = 0;
        valid_decode = 1;
        min_burst = 9999;
        max_burst = 0;
        
        // First pass: measure all burst lengths to find threshold
        unsigned int burst_lengths[4];
        
        for(i = 0; i < CMD_LENGTH; i++)
        {
            // Wait for burst start (TSOP goes LOW)
            timeout = 0;
            while((P3IN & BIT1) != 0) {
                timeout++;
                if(timeout > 5000) {
                    valid_decode = 0;
                    break;
                }
                __delay_cycles(10);
            }
            if(!valid_decode) break;
            
            // Measure burst length
            burst_length = 0;
            while((P3IN & BIT1) == 0) {
                burst_length++;
                if(burst_length > 3000) {
                    valid_decode = 0;
                    break;
                }
                __delay_cycles(1);
            }
            if(!valid_decode) break;
            
            // Store burst length
            burst_lengths[i] = burst_length;
            
            // Track min and max
            if(burst_length < min_burst && burst_length > 10) {
                min_burst = burst_length;
            }
            if(burst_length > max_burst) {
                max_burst = burst_length;
            }
            
            // Wait for gap between bits
            __delay_cycles(3000);
        }
        
        if(!valid_decode) {
            continue;
        }
        
        // Calculate threshold as midpoint between shortest and longest burst
        threshold = (min_burst + max_burst) / 2;
        
        // Second pass: decode the bits using the threshold
        received_cmd = 0;
        for(i = 0; i < CMD_LENGTH; i++) {
            received_cmd <<= 1;
            if(burst_lengths[i] > threshold) {
                received_cmd |= 1;  // Long burst = '1'
            }
            // Short burst = '0' (default)
        }
        
        // Turn off all command LEDs
        P3OUT &= ~(BIT3 | BIT6 | BIT7);
        P2OUT &= ~BIT2;
        
        // Light up the correct LED based on received command
        switch(received_cmd)
        {
            case 0x01:  // 0001 - Button 1
                P3OUT |= BIT3;
                __delay_cycles(1000000);
                P3OUT &= ~BIT3;
                break;
                
            case 0x02:  // 0010 - Button 2
                P3OUT |= BIT6;
                __delay_cycles(1000000);
                P3OUT &= ~BIT6;
                break;
                
            case 0x04:  // 0100 - Button 3
                P3OUT |= BIT7;
                __delay_cycles(1000000);
                P3OUT &= ~BIT7;
                break;
                
            case 0x08:  // 1000 - Button 4
                P2OUT |= BIT2;
                __delay_cycles(1000000);
                P2OUT &= ~BIT2;
                break;
                
            default:
                // Unknown command - quick blink all
                P3OUT |= (BIT3 | BIT6 | BIT7);
                P2OUT |= BIT2;
                __delay_cycles(200000);
                P3OUT &= ~(BIT3 | BIT6 | BIT7);
                P2OUT &= ~BIT2;
                break;
        }
        
        // Small delay before next decode
        __delay_cycles(50000);
    }
}
